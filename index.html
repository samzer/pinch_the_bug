<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinch the Bug</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1B8B6A;
            min-height: 100vh;
            overflow: hidden;
            color: white;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #videoContainer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            overflow: hidden;
            border: 3px solid rgba(255, 255, 255, 0.3);
            z-index: 10;
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 5;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 25px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            font-size: 12px;
            text-transform: uppercase;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
        }

        #score .stat-value {
            color: #4ade80;
        }

        #handStatus {
            position: absolute;
            top: 130px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 5;
        }

        /* Flip Clock Timer */
        #flipTimer {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
        }

        .flip-clock {
            display: flex;
            gap: 6px;
            justify-content: center;
        }

        .flip-digit {
            position: relative;
            width: 55px;
            height: 75px;
            perspective: 300px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        /* Center line divider */
        .flip-digit::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: #222;
            transform: translateY(-50%);
            z-index: 10;
        }

        .flip-digit .digit-top,
        .flip-digit .digit-bottom {
            position: absolute;
            width: 100%;
            height: 50%;
            overflow: hidden;
            background: #3a3a3a;
        }

        .flip-digit .digit-top {
            top: 0;
            border-radius: 6px 6px 0 0;
            background: linear-gradient(180deg, #4d4d4d 0%, #3a3a3a 100%);
            border-bottom: 1px solid #222;
        }

        .flip-digit .digit-bottom {
            bottom: 0;
            border-radius: 0 0 6px 6px;
            background: linear-gradient(180deg, #333 0%, #2a2a2a 100%);
        }

        .flip-digit .digit-top span,
        .flip-digit .digit-bottom span {
            position: absolute;
            width: 100%;
            height: 200%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 52px;
            font-weight: bold;
            color: #f5f5f5;
            font-family: 'Arial Black', Arial, sans-serif;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .flip-digit .digit-top span {
            top: 0;
        }

        .flip-digit .digit-bottom span {
            bottom: 0;
        }

        /* Flip animation panels */
        .flip-digit .digit-flip-top,
        .flip-digit .digit-flip-bottom {
            position: absolute;
            width: 100%;
            height: 50%;
            overflow: hidden;
            backface-visibility: hidden;
        }

        .flip-digit .digit-flip-top {
            top: 0;
            transform-origin: bottom center;
            border-radius: 6px 6px 0 0;
            background: linear-gradient(180deg, #4d4d4d 0%, #3a3a3a 100%);
            z-index: 3;
            display: none;
        }

        .flip-digit .digit-flip-top span {
            position: absolute;
            width: 100%;
            height: 200%;
            top: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 52px;
            font-weight: bold;
            color: #f5f5f5;
            font-family: 'Arial Black', Arial, sans-serif;
        }

        .flip-digit .digit-flip-bottom {
            bottom: 0;
            transform-origin: top center;
            transform: rotateX(90deg);
            border-radius: 0 0 6px 6px;
            background: linear-gradient(180deg, #333 0%, #2a2a2a 100%);
            z-index: 2;
            display: none;
        }

        .flip-digit .digit-flip-bottom span {
            position: absolute;
            width: 100%;
            height: 200%;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 52px;
            font-weight: bold;
            color: #f5f5f5;
            font-family: 'Arial Black', Arial, sans-serif;
        }

        .flip-digit.flipping .digit-flip-top {
            display: block;
            animation: flipDown 0.3s ease-in forwards;
        }

        .flip-digit.flipping .digit-flip-bottom {
            display: block;
            animation: flipUp 0.3s ease-out 0.15s forwards;
        }

        @keyframes flipDown {
            0% { transform: rotateX(0deg); }
            100% { transform: rotateX(-90deg); }
        }

        @keyframes flipUp {
            0% { transform: rotateX(90deg); }
            100% { transform: rotateX(0deg); }
        }

        .timer-label {
            margin-top: 8px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: bold;
        }

        /* Warning state for low time */
        .flip-digit.warning .digit-top span,
        .flip-digit.warning .digit-bottom span,
        .flip-digit.warning .digit-flip-top span,
        .flip-digit.warning .digit-flip-bottom span {
            color: #ff5555;
        }

        #handStatus.detected {
            background: rgba(74, 222, 128, 0.3);
            border: 1px solid #4ade80;
        }

        #handStatus.lost {
            background: rgba(239, 68, 68, 0.3);
            border: 1px solid #ef4444;
        }

        #siteLink {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-size: 14px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            pointer-events: auto;
            z-index: 15;
        }

        #siteLink:hover {
            color: white;
            background: rgba(0, 0, 0, 0.5);
        }

        /* Sound Toggle Button */
        .sound-btn {
            position: absolute;
            top: 20px;
            right: 230px;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.4);
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 15;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .sound-btn:hover {
            background: rgba(0, 0, 0, 0.6);
            transform: scale(1.1);
        }

        .sound-btn.muted {
            opacity: 0.6;
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .modal.hidden {
            display: none;
        }

        .hidden {
            display: none !important;
        }

        .modal-content {
            background: linear-gradient(135deg, #2d2d44 0%, #1a1a2e 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        }

        .modal-content h2 {
            font-size: 32px;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #4ade80, #22d3ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .modal-content p {
            margin-bottom: 15px;
            line-height: 1.6;
            opacity: 0.9;
        }

        .instructions-list {
            text-align: left;
            margin: 20px 0;
            padding-left: 20px;
        }

        .instructions-list li {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .btn {
            padding: 15px 40px;
            font-size: 18px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(90deg, #4ade80, #22d3ee);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(74, 222, 128, 0.4);
        }

        .btn-secondary {
            background: transparent;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .calibration-area {
            margin: 30px 0;
        }

        .slider-container {
            margin: 20px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(90deg, #4ade80, #22d3ee);
            cursor: pointer;
        }

        .test-area {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
            border: 2px dashed rgba(255, 255, 255, 0.2);
        }

        .test-cursor {
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #4ade80, #22d3ee);
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
            display: none;
        }

        .final-score {
            font-size: 64px;
            font-weight: bold;
            background: linear-gradient(90deg, #4ade80, #22d3ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 20px 0;
        }

        .name-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 18px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            margin: 20px 0;
            text-align: center;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .name-input:focus {
            border-color: #4ade80;
        }

        .name-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .name-error {
            color: #ef4444;
            font-size: 14px;
            margin: -10px 0 15px 0;
            padding: 8px 12px;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .name-input.error {
            border-color: #ef4444;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .leaderboard-item.current-player {
            background: rgba(74, 222, 128, 0.2);
            border: 1px solid #4ade80;
        }

        .leaderboard-rank {
            font-weight: bold;
            color: #4ade80;
            min-width: 30px;
        }

        .leaderboard-name {
            flex: 1;
            margin-left: 10px;
        }

        .leaderboard-score {
            font-weight: bold;
            color: #22d3ee;
        }

        .loading-spinner {
            text-align: center;
            padding: 20px;
            color: rgba(255, 255, 255, 0.7);
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-pagination {
            padding: 8px 16px;
            font-size: 14px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-pagination:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.1);
            border-color: #4ade80;
        }

        .btn-pagination:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .pagination-info {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            min-width: 80px;
            text-align: center;
        }

        .your-score-box {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(34, 211, 238, 0.2) 100%);
            border: 2px solid #4ade80;
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 20px;
        }

        .your-score-label {
            font-size: 12px;
            text-transform: uppercase;
            opacity: 0.8;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        .your-score-details {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .your-rank {
            font-size: 24px;
            font-weight: bold;
            color: #4ade80;
            min-width: 50px;
        }

        .your-name {
            flex: 1;
            font-size: 18px;
            font-weight: 500;
        }

        .your-score {
            font-size: 28px;
            font-weight: bold;
            color: #22d3ee;
        }

        .high-scores {
            margin: 20px 0;
            text-align: left;
        }

        .high-scores h3 {
            margin-bottom: 15px;
            text-align: center;
        }

        #leaderboardList,
        #menuLeaderboardList {
            max-height: 350px;
            overflow-y: auto;
        }

        #leaderboardList::-webkit-scrollbar,
        #menuLeaderboardList::-webkit-scrollbar {
            width: 8px;
        }

        #leaderboardList::-webkit-scrollbar-track,
        #menuLeaderboardList::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        #leaderboardList::-webkit-scrollbar-thumb,
        #menuLeaderboardList::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        #leaderboardList::-webkit-scrollbar-thumb:hover,
        #menuLeaderboardList::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .high-score-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 5px;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes pop {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        .target-spawn {
            animation: pop 0.3s ease-out;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="videoContainer">
            <video id="webcam" autoplay playsinline></video>
        </div>

        <div id="ui">
            <div class="stat-box" id="score">
                <div class="stat-label">Score</div>
                <div class="stat-value">0</div>
            </div>
        </div>

        <!-- Sound Toggle Button -->
        <button id="soundToggle" class="sound-btn" title="Toggle Sound">
            <span class="sound-on">üîä</span>
            <span class="sound-off" style="display:none;">üîá</span>
        </button>

        <!-- Flip Clock Timer -->
        <div id="flipTimer">
            <div class="flip-clock">
                <div class="flip-digit" id="digit-tens">
                    <div class="digit-top"><span>3</span></div>
                    <div class="digit-bottom"><span>3</span></div>
                    <div class="digit-flip-top"></div>
                    <div class="digit-flip-bottom"></div>
                </div>
                <div class="flip-digit" id="digit-ones">
                    <div class="digit-top"><span>0</span></div>
                    <div class="digit-bottom"><span>0</span></div>
                    <div class="digit-flip-top"></div>
                    <div class="digit-flip-bottom"></div>
                </div>
            </div>
            <div class="timer-label">TIME</div>
        </div>

        <a href="https://www.samirmadhavan.com?utm_source=pinch_the_bug&utm_medium=game&utm_campaign=bug_game" target="_blank" id="siteLink">samirmadhavan.com</a>

        <div id="handStatus">Waiting for camera...</div>

        <!-- Start/Calibration Modal -->
        <div class="modal" id="startModal">
            <div class="modal-content">
                <h2>Pinch the Bug</h2>
                <p>Use your fly swatter to squash the bugs!</p>

                <div class="calibration-area">
                    <div class="slider-container">
                        <label>Tracking Smoothness: <span id="smoothnessValue">0.3</span></label>
                        <input type="range" class="slider" id="smoothnessSlider" min="0.1" max="0.8" step="0.05" value="0.3">
                    </div>

                    <div class="test-area" id="testArea">
                        <div class="test-cursor" id="testCursor"></div>
                        <p style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0.5;">
                            Move your finger here to test
                        </p>
                    </div>
                </div>

                <div id="cameraError" class="error-message hidden">
                    <strong>Camera Error</strong>
                    <p id="errorText"></p>
                </div>

                <button class="btn btn-primary" id="startBtn" disabled>Start Game</button>
                <button class="btn btn-secondary" id="viewLeaderboardBtn">View Leaderboard</button>
            </div>
        </div>

        <!-- Leaderboard Modal (from menu) -->
        <div class="modal hidden" id="leaderboardModal">
            <div class="modal-content">
                <h2>Leaderboard</h2>
                <div class="high-scores">
                    <h3>All Players</h3>
                    <div id="menuLeaderboardList"></div>
                    <div class="pagination hidden" id="menuPagination">
                        <button class="btn-pagination" id="menuPrevBtn" disabled>&laquo; Prev</button>
                        <span class="pagination-info" id="menuPageInfo">Page 1</span>
                        <button class="btn-pagination" id="menuNextBtn">Next &raquo;</button>
                    </div>
                </div>
                <button class="btn btn-primary" id="closeLeaderboardBtn">Back</button>
            </div>
        </div>

        <!-- Instructions Modal -->
        <div class="modal hidden" id="instructionsModal">
            <div class="modal-content">
                <h2>How to Play</h2>
                <ul class="instructions-list">
                    <li><strong>Point</strong> your index finger to control the fly swatter</li>
                    <li><strong>Hover</strong> over a bug to charge up the swatter</li>
                    <li><strong>Hold</strong> on the bug until the swatter squashes it!</li>
                    <li>Squash as many bugs as you can before time runs out!</li>
                </ul>
                <button class="btn btn-primary" id="playBtn">Play!</button>
            </div>
        </div>

        <!-- Name Input Modal -->
        <div class="modal hidden" id="nameModal">
            <div class="modal-content">
                <h2>New High Score!</h2>
                <div class="final-score" id="finalScoreDisplay">0</div>
                <p>Enter your name for the leaderboard:</p>
                <input type="text" id="playerNameInput" class="name-input" placeholder="Your name" maxlength="20" autocomplete="off">
                <p id="nameError" class="name-error hidden"></p>
                <button class="btn btn-primary" id="submitScoreBtn">Submit Score</button>
                <button class="btn btn-secondary" id="skipScoreBtn">Skip</button>
            </div>
        </div>

        <!-- Not Higher Score Modal -->
        <div class="modal hidden" id="notHigherModal">
            <div class="modal-content">
                <h2>Game Over!</h2>
                <div class="final-score" id="notHigherScore">0</div>
                <p style="margin-bottom: 10px;">Your high score: <strong id="existingHighScore">0</strong></p>
                <p style="opacity: 0.7;">Beat your high score to update the leaderboard!</p>
                <button class="btn btn-primary" id="tryAgainBtn">Try Again</button>
                <button class="btn btn-secondary" id="viewLeaderboardBtn2">View Leaderboard</button>
            </div>
        </div>

        <!-- Game Over Modal -->
        <div class="modal hidden" id="gameOverModal">
            <div class="modal-content">
                <h2>Leaderboard</h2>

                <div class="your-score-box" id="yourScoreBox">
                    <div class="your-score-label">Your Score</div>
                    <div class="your-score-details">
                        <span class="your-rank" id="yourRank">#1</span>
                        <span class="your-name" id="yourName">Player</span>
                        <span class="your-score" id="yourScore">0</span>
                    </div>
                </div>

                <div class="high-scores">
                    <h3>All Players</h3>
                    <div id="leaderboardList"></div>
                    <div class="pagination hidden" id="gameOverPagination">
                        <button class="btn-pagination" id="gameOverPrevBtn" disabled>&laquo; Prev</button>
                        <span class="pagination-info" id="gameOverPageInfo">Page 1</span>
                        <button class="btn-pagination" id="gameOverNextBtn">Next &raquo;</button>
                    </div>
                </div>

                <button class="btn btn-primary" id="restartBtn">Play Again</button>
                <button class="btn btn-secondary" id="menuBtn">Main Menu</button>
            </div>
        </div>

        <!-- Paused Overlay -->
        <div class="modal hidden" id="pausedModal">
            <div class="modal-content">
                <h2>Paused</h2>
                <p>Hand not detected. Show your hand to continue!</p>
            </div>
        </div>

        <!-- Mobile Not Supported Modal -->
        <div class="modal hidden" id="mobileModal">
            <div class="modal-content">
                <h2>Desktop Only</h2>
                <div style="font-size: 64px; margin: 20px 0;">üñ•Ô∏è</div>
                <p style="margin-bottom: 15px;">Pinch the Bug requires a webcam and hand tracking, which works best on desktop computers.</p>
                <p style="opacity: 0.7;">Please visit this page on a desktop or laptop computer with a webcam to play!</p>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
        // ============================================
        // Supabase Setup
        // ============================================
        const SUPABASE_URL = 'https://iroodimcnvaklsutipqe.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_CMXSOy3YCvFwYDnrdpkesQ_rUwKgTB7';
        let supabaseClient = null;

        // Initialize Supabase when ready
        function initSupabase() {
            if (window.supabase && window.supabase.createClient) {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                console.log('Supabase initialized');
            } else {
                console.warn('Supabase library not loaded');
            }
        }

        // ============================================
        // Profanity Filter
        // ============================================
        const inappropriateWords = [
            'fuck', 'shit', 'ass', 'bitch', 'damn', 'crap', 'piss', 'dick', 'cock',
            'pussy', 'asshole', 'bastard', 'slut', 'whore', 'fag', 'faggot', 'nigger',
            'nigga', 'cunt', 'twat', 'wanker', 'bollocks', 'arse', 'retard', 'gay',
            'penis', 'vagina', 'sex', 'porn', 'nude', 'naked', 'xxx', 'anal', 'rape',
            'kill', 'murder', 'nazi', 'hitler', 'terrorist', 'bomb'
        ];

        function containsInappropriateContent(name) {
            // Normalize: lowercase and replace common letter substitutions
            const normalized = name.toLowerCase()
                .replace(/0/g, 'o')
                .replace(/1/g, 'i')
                .replace(/3/g, 'e')
                .replace(/4/g, 'a')
                .replace(/5/g, 's')
                .replace(/7/g, 't')
                .replace(/8/g, 'b')
                .replace(/@/g, 'a')
                .replace(/\$/g, 's')
                .replace(/[^a-z]/g, ''); // Remove non-letters

            // Check for inappropriate words
            for (const word of inappropriateWords) {
                if (normalized.includes(word)) {
                    return true;
                }
            }

            // Also check the original (with spaces removed) for exact matches
            const originalClean = name.toLowerCase().replace(/\s+/g, '');
            for (const word of inappropriateWords) {
                if (originalClean.includes(word)) {
                    return true;
                }
            }

            return false;
        }

        // ============================================
        // Coordinate Smoother
        // ============================================
        class CoordinateSmoother {
            constructor(alpha = 0.3) {
                this.alpha = alpha;
                this.x = null;
                this.y = null;
            }

            smooth(newX, newY) {
                if (this.x === null) {
                    this.x = newX;
                    this.y = newY;
                } else {
                    this.x = this.alpha * newX + (1 - this.alpha) * this.x;
                    this.y = this.alpha * newY + (1 - this.alpha) * this.y;
                }
                return { x: this.x, y: this.y };
            }

            reset() {
                this.x = null;
                this.y = null;
            }

            setAlpha(alpha) {
                this.alpha = alpha;
            }
        }

        // ============================================
        // Bug Death Phrases
        // ============================================
        const deathPhrases = [
            "NOOO!", "WHY?!", "OOF!", "SPLAT!", "ACK!", "UGH!",
            "NOT COOL!", "RUDE!", "MY LEG!", "OUCH!", "BYE BYE!",
            "TELL MY WIFE...", "I HAD PLANS!", "SO FLAT!", "*SQUISH*",
            "CURSE YOU!", "AVENGE ME!", "WORTH IT!", "NO REGRETS!",
            "I WAS JUST...", "BUT I'M CUTE!", "MOMMY!", "NOOOPE!",
            "TOO YOUNG!", "MY BABIES!", "UNFAIR!", "MEDIC!",
            "X_X", "RIP ME", "GG", "I'LL BE BACK!", "NOT AGAIN!",
            "SO THIS IS...", "BETRAYED!", "WHY ME?!", "HALP!"
        ];

        const scaredPhrases = [
            "OH NO!", "PLEASE NO!", "NOT THE SWATTER!", "AAAH!",
            "SPARE ME!", "I'M TOO PRETTY!", "HAVE MERCY!", "WAIT WAIT!",
            "I HAVE KIDS!", "RUN AWAY!", "NOPE NOPE!", "HELP!",
            "MOMMY!", "NOT TODAY!", "PANIC!", "EEK!", "OH CRUD!",
            "YIKES!", "GULP!", "UH OH..."
        ];

        // ============================================
        // Sound System
        // ============================================
        class SoundSystem {
            constructor() {
                this.enabled = true;
                this.audioContext = null;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch (e) {
                    console.warn('Web Audio API not supported');
                }
            }

            toggle() {
                this.enabled = !this.enabled;
                return this.enabled;
            }

            playSquish() {
                if (!this.enabled || !this.initialized) return;

                try {
                    const ctx = this.audioContext;
                    const now = ctx.currentTime;

                    // Randomize pitch slightly for variety
                    const pitchVar = 0.9 + Math.random() * 0.2;

                    // === Layer 1: Satisfying "pop" attack ===
                    const popOsc = ctx.createOscillator();
                    popOsc.type = 'sine';
                    popOsc.frequency.setValueAtTime(400 * pitchVar, now);
                    popOsc.frequency.exponentialRampToValueAtTime(80, now + 0.08);

                    const popGain = ctx.createGain();
                    popGain.gain.setValueAtTime(0.4, now);
                    popGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                    popOsc.connect(popGain);
                    popGain.connect(ctx.destination);
                    popOsc.start(now);
                    popOsc.stop(now + 0.1);

                    // === Layer 2: Wet "splat" noise ===
                    const splatDuration = 0.2;
                    const splatBuffer = ctx.createBuffer(1, ctx.sampleRate * splatDuration, ctx.sampleRate);
                    const splatData = splatBuffer.getChannelData(0);
                    for (let i = 0; i < splatData.length; i++) {
                        const t = i / splatData.length;
                        // Shaped noise with quick attack, smooth decay
                        const envelope = Math.pow(1 - t, 1.5) * (t < 0.1 ? t * 10 : 1);
                        splatData[i] = (Math.random() * 2 - 1) * envelope;
                    }

                    const splatNoise = ctx.createBufferSource();
                    splatNoise.buffer = splatBuffer;

                    // Bandpass filter for wet splat character
                    const splatFilter = ctx.createBiquadFilter();
                    splatFilter.type = 'bandpass';
                    splatFilter.frequency.setValueAtTime(1200 * pitchVar, now);
                    splatFilter.frequency.exponentialRampToValueAtTime(400, now + splatDuration);
                    splatFilter.Q.value = 1.5;

                    const splatGain = ctx.createGain();
                    splatGain.gain.setValueAtTime(0.35, now);
                    splatGain.gain.exponentialRampToValueAtTime(0.01, now + splatDuration);

                    splatNoise.connect(splatFilter);
                    splatFilter.connect(splatGain);
                    splatGain.connect(ctx.destination);
                    splatNoise.start(now);
                    splatNoise.stop(now + splatDuration);

                    // === Layer 3: Deep thump for impact ===
                    const thumpOsc = ctx.createOscillator();
                    thumpOsc.type = 'sine';
                    thumpOsc.frequency.setValueAtTime(120 * pitchVar, now);
                    thumpOsc.frequency.exponentialRampToValueAtTime(40, now + 0.15);

                    const thumpGain = ctx.createGain();
                    thumpGain.gain.setValueAtTime(0.5, now);
                    thumpGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                    // Add slight distortion for punch
                    const thumpShaper = ctx.createWaveShaper();
                    const curve = new Float32Array(256);
                    for (let i = 0; i < 256; i++) {
                        const x = (i / 128) - 1;
                        curve[i] = Math.tanh(x * 2);
                    }
                    thumpShaper.curve = curve;

                    thumpOsc.connect(thumpShaper);
                    thumpShaper.connect(thumpGain);
                    thumpGain.connect(ctx.destination);
                    thumpOsc.start(now);
                    thumpOsc.stop(now + 0.15);

                    // === Layer 4: High "squeak" for cartoon effect ===
                    const squeakOsc = ctx.createOscillator();
                    squeakOsc.type = 'sine';
                    squeakOsc.frequency.setValueAtTime(800 * pitchVar, now + 0.02);
                    squeakOsc.frequency.exponentialRampToValueAtTime(200, now + 0.12);

                    const squeakGain = ctx.createGain();
                    squeakGain.gain.setValueAtTime(0, now);
                    squeakGain.gain.linearRampToValueAtTime(0.15, now + 0.03);
                    squeakGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);

                    squeakOsc.connect(squeakGain);
                    squeakGain.connect(ctx.destination);
                    squeakOsc.start(now + 0.02);
                    squeakOsc.stop(now + 0.12);

                } catch (e) {
                    console.warn('Error playing sound:', e);
                }
            }
        }

        const soundSystem = new SoundSystem();

        // ============================================
        // Bug Class
        // ============================================
        class Bug {
            constructor(x, y, bugType, canvasWidth, canvasHeight) {
                this.x = x;
                this.y = y;
                this.size = bugType.size;
                this.color = bugType.color;
                this.points = bugType.points;
                this.typeName = bugType.name;
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;

                // Random direction
                const speed = bugType.speed;
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.angle = angle; // Bug faces direction of movement

                this.spawnTime = Date.now();
                this.scale = 0;
                this.hit = false;
                this.hitTime = 0;
                this.legPhase = 0; // For leg animation
                this.wiggle = 0; // Body wiggle
                this.dwellThreshold = bugType.dwellThreshold; // Time to squash
                this.dwellTime = 0; // Current dwell time

                // Personality
                this.deathPhrase = deathPhrases[Math.floor(Math.random() * deathPhrases.length)];
                this.scaredPhrase = scaredPhrases[Math.floor(Math.random() * scaredPhrases.length)];
                this.isScared = false;
                this.eyeDirection = { x: 0, y: 0 }; // For looking around
                this.blinkTimer = Math.random() * 3000;
                this.isBlinking = false;
            }

            update(deltaTime, canvasWidth, canvasHeight, cursorX, cursorY) {
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;

                // Spawn animation
                if (this.scale < 1) {
                    this.scale = Math.min(1, this.scale + deltaTime * 0.005);
                }

                // Hit animation
                if (this.hit) {
                    this.hitTime += deltaTime;
                    return this.hitTime < 800; // Longer for speech bubble
                }

                // Move (faster if scared!)
                const speedMultiplier = this.isScared ? 1.5 : 1;
                this.x += this.vx * deltaTime * 0.06 * speedMultiplier;
                this.y += this.vy * deltaTime * 0.06 * speedMultiplier;

                // Animate legs and wiggle (faster if scared)
                const legSpeed = this.isScared ? 0.04 : 0.02;
                this.legPhase += deltaTime * legSpeed;
                this.wiggle = Math.sin(this.legPhase * 2) * (this.isScared ? 0.2 : 0.1);

                // Update facing angle based on velocity
                this.angle = Math.atan2(this.vy, this.vx);

                // Eye tracking - look at cursor
                if (cursorX !== undefined && cursorY !== undefined) {
                    const dx = cursorX - this.x;
                    const dy = cursorY - this.y;
                    const dist = Math.hypot(dx, dy);
                    this.eyeDirection.x = (dx / dist) * 0.3 || 0;
                    this.eyeDirection.y = (dy / dist) * 0.3 || 0;

                    // Get scared if swatter is close (within 1.5x bug size)
                    const scareDistance = this.size * 1.5;
                    this.isScared = dist < scareDistance;
                }

                // Blinking
                this.blinkTimer -= deltaTime;
                if (this.blinkTimer <= 0) {
                    this.isBlinking = true;
                    this.blinkTimer = 2000 + Math.random() * 3000;
                    setTimeout(() => { this.isBlinking = false; }, 150);
                }

                // Bounce off walls
                const radius = (this.size * this.scale) / 2;
                if (this.x - radius < 0) {
                    this.x = radius;
                    this.vx *= -1;
                } else if (this.x + radius > canvasWidth) {
                    this.x = canvasWidth - radius;
                    this.vx *= -1;
                }
                if (this.y - radius < 0) {
                    this.y = radius;
                    this.vy *= -1;
                } else if (this.y + radius > canvasHeight) {
                    this.y = canvasHeight - radius;
                    this.vy *= -1;
                }

                return true;
            }

            draw(ctx) {
                const s = this.size * this.scale;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI / 2 + this.wiggle); // Bug points in movement direction

                if (this.hit) {
                    // Squash animation
                    const progress = this.hitTime / 800;
                    const alpha = 1 - progress;
                    const squash = 1 + Math.min(progress * 2, 1) * 0.5;

                    ctx.scale(squash, 1 / squash);

                    // Splat effect
                    ctx.beginPath();
                    ctx.arc(0, 0, s * 0.6 * squash, 0, Math.PI * 2);
                    ctx.fillStyle = this.color.replace('1)', `${alpha * 0.5})`);
                    ctx.fill();

                    // Bug body fading
                    ctx.beginPath();
                    ctx.ellipse(0, 0, s * 0.3, s * 0.4, 0, 0, Math.PI * 2);
                    ctx.fillStyle = this.color.replace('1)', `${alpha})`);
                    ctx.fill();

                    // X_X eyes when dead
                    if (progress < 0.7) {
                        ctx.strokeStyle = `rgba(0, 0, 0, ${alpha})`;
                        ctx.lineWidth = 3;
                        // Left X
                        ctx.beginPath();
                        ctx.moveTo(-s * 0.12, -s * 0.45);
                        ctx.lineTo(-s * 0.02, -s * 0.35);
                        ctx.moveTo(-s * 0.02, -s * 0.45);
                        ctx.lineTo(-s * 0.12, -s * 0.35);
                        ctx.stroke();
                        // Right X
                        ctx.beginPath();
                        ctx.moveTo(s * 0.02, -s * 0.45);
                        ctx.lineTo(s * 0.12, -s * 0.35);
                        ctx.moveTo(s * 0.12, -s * 0.45);
                        ctx.lineTo(s * 0.02, -s * 0.35);
                        ctx.stroke();
                    }

                    // Splatter particles
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const dist = progress * s * 1.5;
                        ctx.beginPath();
                        ctx.arc(
                            Math.cos(angle) * dist,
                            Math.sin(angle) * dist,
                            s * 0.1 * (1 - progress),
                            0, Math.PI * 2
                        );
                        ctx.fillStyle = this.color.replace('1)', `${alpha})`);
                        ctx.fill();
                    }

                    ctx.restore();

                    // Draw death speech bubble (outside rotation)
                    if (progress < 0.8) {
                        this.drawSpeechBubble(ctx, this.deathPhrase, 1 - progress * 1.2);
                    }
                    return;
                }

                // Draw scared speech bubble when swatter is close
                if (this.isScared) {
                    ctx.restore();
                    this.drawSpeechBubble(ctx, this.scaredPhrase, 0.9);
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle + Math.PI / 2 + this.wiggle);
                }

                // Legs (3 pairs)
                const legLength = s * 0.5;
                const legWidth = s * 0.08;
                ctx.strokeStyle = this.color.replace('1)', '0.8)');
                ctx.lineWidth = legWidth;
                ctx.lineCap = 'round';

                for (let i = 0; i < 3; i++) {
                    const yOffset = (i - 1) * s * 0.25;
                    const legSwing = Math.sin(this.legPhase + i * 1.5) * 0.3;

                    // Left leg
                    ctx.beginPath();
                    ctx.moveTo(-s * 0.2, yOffset);
                    ctx.quadraticCurveTo(
                        -legLength * 0.7, yOffset + legSwing * s * 0.3,
                        -legLength, yOffset + legSwing * s * 0.5
                    );
                    ctx.stroke();

                    // Right leg
                    ctx.beginPath();
                    ctx.moveTo(s * 0.2, yOffset);
                    ctx.quadraticCurveTo(
                        legLength * 0.7, yOffset - legSwing * s * 0.3,
                        legLength, yOffset - legSwing * s * 0.5
                    );
                    ctx.stroke();
                }

                // Body (abdomen)
                ctx.beginPath();
                ctx.ellipse(0, s * 0.15, s * 0.28, s * 0.35, 0, 0, Math.PI * 2);
                const bodyGradient = ctx.createRadialGradient(0, s * 0.15, 0, 0, s * 0.15, s * 0.35);
                bodyGradient.addColorStop(0, this.color);
                bodyGradient.addColorStop(1, this.color.replace('1)', '0.6)'));
                ctx.fillStyle = bodyGradient;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Thorax
                ctx.beginPath();
                ctx.ellipse(0, -s * 0.15, s * 0.2, s * 0.18, 0, 0, Math.PI * 2);
                ctx.fillStyle = this.color.replace('1)', '0.9)');
                ctx.fill();
                ctx.stroke();

                // Head
                ctx.beginPath();
                ctx.ellipse(0, -s * 0.38, s * 0.15, s * 0.12, 0, 0, Math.PI * 2);
                ctx.fillStyle = this.color.replace('1)', '0.85)');
                ctx.fill();
                ctx.stroke();

                // Eyes
                const eyeY = -s * 0.4;
                const eyeSize = this.isScared ? s * 0.08 : s * 0.06; // Bigger when scared

                // Eye whites
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-s * 0.07, eyeY, eyeSize, 0, Math.PI * 2);
                ctx.arc(s * 0.07, eyeY, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Pupils (follow cursor direction, unless blinking)
                if (!this.isBlinking) {
                    const pupilOffset = eyeSize * 0.4;
                    const pupilSize = this.isScared ? s * 0.02 : s * 0.03; // Smaller when scared
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-s * 0.07 + this.eyeDirection.x * pupilOffset, eyeY + this.eyeDirection.y * pupilOffset, pupilSize, 0, Math.PI * 2);
                    ctx.arc(s * 0.07 + this.eyeDirection.x * pupilOffset, eyeY + this.eyeDirection.y * pupilOffset, pupilSize, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Closed eyes (blinking)
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-s * 0.11, eyeY);
                    ctx.lineTo(-s * 0.03, eyeY);
                    ctx.moveTo(s * 0.03, eyeY);
                    ctx.lineTo(s * 0.11, eyeY);
                    ctx.stroke();
                }

                // Scared eyebrows
                if (this.isScared) {
                    ctx.strokeStyle = this.color.replace('1)', '0.8)');
                    ctx.lineWidth = 2;
                    // Left eyebrow (angled up)
                    ctx.beginPath();
                    ctx.moveTo(-s * 0.12, eyeY - s * 0.08);
                    ctx.lineTo(-s * 0.02, eyeY - s * 0.12);
                    ctx.stroke();
                    // Right eyebrow (angled up)
                    ctx.beginPath();
                    ctx.moveTo(s * 0.02, eyeY - s * 0.12);
                    ctx.lineTo(s * 0.12, eyeY - s * 0.08);
                    ctx.stroke();
                }

                // Antennae
                ctx.strokeStyle = this.color.replace('1)', '0.7)');
                ctx.lineWidth = s * 0.04;
                ctx.lineCap = 'round';

                const antennaSwing = Math.sin(this.legPhase * 3) * 0.2;
                // Left antenna
                ctx.beginPath();
                ctx.moveTo(-s * 0.08, -s * 0.45);
                ctx.quadraticCurveTo(-s * 0.2, -s * 0.6, -s * 0.15 + antennaSwing * s * 0.2, -s * 0.7);
                ctx.stroke();

                // Right antenna
                ctx.beginPath();
                ctx.moveTo(s * 0.08, -s * 0.45);
                ctx.quadraticCurveTo(s * 0.2, -s * 0.6, s * 0.15 - antennaSwing * s * 0.2, -s * 0.7);
                ctx.stroke();

                ctx.restore();
            }

            checkHit(cursorX, cursorY) {
                const radius = (this.size * this.scale) / 2;
                const distance = Math.hypot(cursorX - this.x, cursorY - this.y);
                return distance < radius;
            }

            drawSpeechBubble(ctx, text, alpha) {
                ctx.save();

                // Position bubble above the bug
                const bubbleX = this.x;
                const bubbleY = this.y - this.size * 0.8;

                // Measure text
                ctx.font = 'bold 14px Arial, sans-serif';
                const textWidth = ctx.measureText(text).width;
                const padding = 10;
                const bubbleWidth = textWidth + padding * 2;
                const bubbleHeight = 28;

                // Bubble background
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.roundRect(
                    bubbleX - bubbleWidth / 2,
                    bubbleY - bubbleHeight / 2,
                    bubbleWidth,
                    bubbleHeight,
                    8
                );
                ctx.fill();

                // Bubble border
                ctx.strokeStyle = `rgba(0, 0, 0, ${alpha * 0.3})`;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Bubble tail (triangle pointing down)
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.moveTo(bubbleX - 8, bubbleY + bubbleHeight / 2 - 2);
                ctx.lineTo(bubbleX, bubbleY + bubbleHeight / 2 + 10);
                ctx.lineTo(bubbleX + 8, bubbleY + bubbleHeight / 2 - 2);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = `rgba(0, 0, 0, ${alpha * 0.3})`;
                ctx.beginPath();
                ctx.moveTo(bubbleX - 8, bubbleY + bubbleHeight / 2 - 1);
                ctx.lineTo(bubbleX, bubbleY + bubbleHeight / 2 + 10);
                ctx.lineTo(bubbleX + 8, bubbleY + bubbleHeight / 2 - 1);
                ctx.stroke();

                // Text
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, bubbleX, bubbleY);

                ctx.restore();
            }
        }

        // ============================================
        // Game Class
        // ============================================
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.video = document.getElementById('webcam');

                // Game state
                this.state = 'CALIBRATION'; // CALIBRATION, INSTRUCTIONS, PLAYING, PAUSED, GAME_OVER
                this.score = 0;
                this.timeRemaining = 60;
                this.targets = [];
                this.lastFrameTime = 0;
                this.lastSpawnTime = 0;

                // Game settings
                this.settings = {
                    spawnInterval: 1000,
                    gameTime: 30,
                    nearMissTolerance: 80
                };

                // Bug types with different characteristics (dwellThreshold = time to squash in ms)
                this.bugTypes = [
                    { name: 'normal', size: 80, speed: 2, points: 10, weight: 40, color: 'rgba(74, 222, 128, 1)', dwellThreshold: 100 },
                    { name: 'fast', size: 60, speed: 4, points: 25, weight: 25, color: 'rgba(251, 191, 36, 1)', dwellThreshold: 100 },
                    { name: 'tiny', size: 45, speed: 3, points: 30, weight: 20, color: 'rgba(244, 114, 182, 1)', dwellThreshold: 100 },
                    { name: 'big', size: 100, speed: 1.5, points: 5, weight: 10, color: 'rgba(239, 68, 68, 1)', dwellThreshold: 100 },
                    { name: 'boss', size: 120, speed: 2.5, points: 50, weight: 5, color: 'rgba(167, 139, 250, 1)', dwellThreshold: 100 }
                ];

                // Cursor state
                this.cursorX = 0;
                this.cursorY = 0;
                this.cursorVisible = false;
                this.smoother = new CoordinateSmoother(0.3);

                // Swatter state (dwell to squash)
                this.currentTarget = null;
                this.swatterAngle = 0; // Swatter tilt angle
                this.isSquashing = false;
                this.squashStartTime = 0;
                this.squashDuration = 200; // Animation duration in ms

                // Hand tracking
                this.hands = null;
                this.camera = null;
                this.handDetected = false;
                this.handLostTime = 0;

                // Leaderboard pagination
                this.leaderboardData = [];
                this.leaderboardPage = 0;
                this.leaderboardPageSize = 50;
                this.leaderboardContext = null; // 'menu' or 'gameOver'

                this.init();
            }

            async init() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.setupUI();
                await this.initMediaPipe();
                this.gameLoop(0);
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupUI() {
                // Smoothness slider
                const slider = document.getElementById('smoothnessSlider');
                const valueDisplay = document.getElementById('smoothnessValue');
                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    valueDisplay.textContent = value.toFixed(2);
                    this.smoother.setAlpha(value);
                });

                // Start button
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.showModal('instructionsModal');
                });

                // Play button
                document.getElementById('playBtn').addEventListener('click', () => {
                    this.startGame();
                });

                // Restart button
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.startGame();
                });

                // Menu button
                document.getElementById('menuBtn').addEventListener('click', () => {
                    this.hideModal('gameOverModal');
                    this.showModal('startModal');
                    this.state = 'CALIBRATION';
                });

                // View leaderboard from start screen
                document.getElementById('viewLeaderboardBtn').addEventListener('click', () => {
                    this.viewLeaderboardFromMenu();
                });

                // Close leaderboard modal
                document.getElementById('closeLeaderboardBtn').addEventListener('click', () => {
                    this.hideModal('leaderboardModal');
                    this.showModal('startModal');
                });

                // Submit score button
                document.getElementById('submitScoreBtn').addEventListener('click', () => {
                    this.submitScore();
                });

                // Skip score button
                document.getElementById('skipScoreBtn').addEventListener('click', () => {
                    this.hideModal('nameModal');
                    this.showLeaderboard();
                });

                // Enter key to submit score
                document.getElementById('playerNameInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.submitScore();
                    }
                });

                // Try again button (from not higher score modal)
                document.getElementById('tryAgainBtn').addEventListener('click', () => {
                    this.hideModal('notHigherModal');
                    this.startGame();
                });

                // View leaderboard from not higher score modal
                document.getElementById('viewLeaderboardBtn2').addEventListener('click', () => {
                    this.hideModal('notHigherModal');
                    this.showLeaderboard();
                });

                // Pagination buttons - Menu leaderboard
                document.getElementById('menuPrevBtn').addEventListener('click', () => {
                    this.leaderboardPage--;
                    this.renderLeaderboardPage();
                });
                document.getElementById('menuNextBtn').addEventListener('click', () => {
                    this.leaderboardPage++;
                    this.renderLeaderboardPage();
                });

                // Pagination buttons - Game over leaderboard
                document.getElementById('gameOverPrevBtn').addEventListener('click', () => {
                    this.leaderboardPage--;
                    this.renderLeaderboardPage();
                });
                document.getElementById('gameOverNextBtn').addEventListener('click', () => {
                    this.leaderboardPage++;
                    this.renderLeaderboardPage();
                });

                // Sound toggle button
                const soundBtn = document.getElementById('soundToggle');
                soundBtn.addEventListener('click', () => {
                    const isEnabled = soundSystem.toggle();
                    soundBtn.querySelector('.sound-on').style.display = isEnabled ? 'block' : 'none';
                    soundBtn.querySelector('.sound-off').style.display = isEnabled ? 'none' : 'block';
                    soundBtn.classList.toggle('muted', !isEnabled);
                });
            }

            async initMediaPipe() {
                // Step 1: Get camera access first
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 640, height: 480, facingMode: 'user' }
                    });

                    this.video.srcObject = stream;
                    await this.video.play();
                    this.updateHandStatus('Camera ready, loading hand tracking...', 'detected');

                } catch (error) {
                    console.error('Camera error:', error);
                    document.getElementById('cameraError').classList.remove('hidden');
                    document.getElementById('errorText').textContent =
                        error.name === 'NotAllowedError'
                            ? 'Camera permission denied. Please allow camera access and refresh.'
                            : `Failed to access camera: ${error.message}`;
                    return;
                }

                // Step 2: Initialize MediaPipe Hands
                try {
                    // Check if MediaPipe loaded
                    if (typeof Hands === 'undefined') {
                        throw new Error('MediaPipe Hands library failed to load. Check your internet connection.');
                    }

                    this.hands = new Hands({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                    });

                    this.hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.7,
                        minTrackingConfidence: 0.5
                    });

                    this.hands.onResults((results) => this.onHandResults(results));

                    // Start manual frame processing loop (model initializes on first send)
                    this.mediaPipeReady = false;
                    this.processVideoFrame();

                    document.getElementById('startBtn').disabled = false;
                    this.updateHandStatus('Move your hand in view', 'detected');

                } catch (error) {
                    console.error('MediaPipe error:', error);
                    document.getElementById('cameraError').classList.remove('hidden');
                    const errorMsg = error.message || error.toString() || 'Unknown error';
                    document.getElementById('errorText').textContent =
                        `Failed to initialize hand tracking: ${errorMsg}. Try refreshing the page.`;
                }
            }

            async processVideoFrame() {
                if (this.video.readyState >= 2) {
                    try {
                        await this.hands.send({ image: this.video });
                        if (!this.mediaPipeReady) {
                            this.mediaPipeReady = true;
                            console.log('MediaPipe Hands initialized successfully');
                        }
                    } catch (e) {
                        if (!this.mediaPipeReady) {
                            console.error('MediaPipe initialization error:', e);
                            document.getElementById('cameraError').classList.remove('hidden');
                            document.getElementById('errorText').textContent =
                                `Hand tracking failed to load. Please refresh the page.`;
                            return; // Stop the loop on init error
                        }
                    }
                }
                requestAnimationFrame(() => this.processVideoFrame());
            }

            onHandResults(results) {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];

                    // Get index finger tip (landmark 8)
                    const indexTip = landmarks[8];

                    // Convert to canvas coordinates (with horizontal flip for mirror mode)
                    const rawX = (1 - indexTip.x) * this.canvas.width;
                    const rawY = indexTip.y * this.canvas.height;

                    // Smooth coordinates
                    const smoothed = this.smoother.smooth(rawX, rawY);
                    this.cursorX = smoothed.x;
                    this.cursorY = smoothed.y;
                    this.cursorVisible = true;

                    // Hand detected
                    if (!this.handDetected) {
                        this.handDetected = true;
                        this.updateHandStatus('Hand detected', 'detected');

                        if (this.state === 'PAUSED') {
                            this.state = 'PLAYING';
                            this.hideModal('pausedModal');
                        }
                    }

                    // Update test cursor in calibration
                    if (this.state === 'CALIBRATION') {
                        this.updateTestCursor(indexTip.x, indexTip.y);
                    }

                } else {
                    // Hand lost
                    if (this.handDetected) {
                        this.handDetected = false;
                        this.cursorVisible = false;
                        this.smoother.reset();
                        // Reset swatter state
                        if (this.currentTarget) {
                            this.currentTarget.dwellTime = 0;
                            this.currentTarget = null;
                        }
                        this.updateHandStatus('Hand lost - show your hand', 'lost');

                        if (this.state === 'PLAYING') {
                            this.handLostTime = Date.now();
                            setTimeout(() => {
                                if (!this.handDetected && this.state === 'PLAYING') {
                                    this.state = 'PAUSED';
                                    this.showModal('pausedModal');
                                }
                            }, 1000);
                        }
                    }

                    // Hide test cursor
                    document.getElementById('testCursor').style.display = 'none';
                }
            }

            updateTestCursor(normX, normY) {
                const testArea = document.getElementById('testArea');
                const testCursor = document.getElementById('testCursor');
                const rect = testArea.getBoundingClientRect();

                // Apply same mirroring as game
                const x = (1 - normX) * rect.width;
                const y = normY * rect.height;

                testCursor.style.display = 'block';
                testCursor.style.left = `${x}px`;
                testCursor.style.top = `${y}px`;
            }

            updateHandStatus(text, className) {
                const status = document.getElementById('handStatus');
                status.textContent = text;
                status.className = className;
            }

            hitTarget(target) {
                target.hit = true;
                this.score += target.points;
                this.updateScoreDisplay();
                this.showPointsPopup(target.x, target.y, target.points);
                soundSystem.playSquish();
            }

            showPointsPopup(x, y, points) {
                // Create floating points text
                const popup = {
                    x: x,
                    y: y,
                    points: points,
                    startTime: Date.now(),
                    duration: 800
                };
                if (!this.pointsPopups) this.pointsPopups = [];
                this.pointsPopups.push(popup);
            }

            startGame() {
                // Initialize sound system (requires user interaction)
                soundSystem.init();

                this.hideAllModals();
                this.state = 'PLAYING';
                this.score = 0;
                this.targets = [];
                this.pointsPopups = [];
                this.timeRemaining = this.settings.gameTime;
                this.lastSpawnTime = Date.now();
                this.currentTarget = null;
                this.isSquashing = false;
                this.squashStartTime = 0;
                this.updateScoreDisplay();
                this.initFlipTimer(); // Initialize timer without animation

                // Remove warning class
                document.getElementById('digit-tens').classList.remove('warning');
                document.getElementById('digit-ones').classList.remove('warning');

                // Spawn initial target
                this.spawnTarget();

                // Start timer
                this.timerInterval = setInterval(() => {
                    if (this.state === 'PLAYING') {
                        this.timeRemaining--;
                        this.updateTimerDisplay();

                        if (this.timeRemaining <= 0) {
                            this.endGame();
                        }
                    }
                }, 1000);
            }

            async endGame() {
                this.state = 'GAME_OVER';
                clearInterval(this.timerInterval);
                this.finalScore = this.score;

                // Check if returning player has a higher existing score
                const rememberedName = localStorage.getItem('pinchTheBugPlayerName') || '';

                if (rememberedName && supabaseClient) {
                    try {
                        const { data: existingPlayers } = await supabaseClient
                            .from('leaderboard')
                            .select('score')
                            .eq('player_name', rememberedName)
                            .order('score', { ascending: false })
                            .limit(1);

                        if (existingPlayers && existingPlayers.length > 0) {
                            const existingHighScore = existingPlayers[0].score;

                            if (this.finalScore <= existingHighScore) {
                                // Score not higher - skip to leaderboard
                                this.currentPlayerName = rememberedName;
                                this.showNotHigherScoreModal(existingHighScore);
                                return;
                            }
                        }
                    } catch (error) {
                        console.error('Error checking existing score:', error);
                    }
                }

                // Show name input modal for new high score
                document.getElementById('finalScoreDisplay').textContent = this.score;
                document.getElementById('playerNameInput').value = rememberedName;
                document.getElementById('nameError').classList.add('hidden');
                document.getElementById('playerNameInput').classList.remove('error');
                this.showModal('nameModal');

                // Focus the input
                setTimeout(() => {
                    const input = document.getElementById('playerNameInput');
                    input.focus();
                    input.select();
                }, 100);
            }

            showNotHigherScoreModal(existingHighScore) {
                document.getElementById('notHigherScore').textContent = this.finalScore;
                document.getElementById('existingHighScore').textContent = existingHighScore;
                this.showModal('notHigherModal');
            }

            showNameError(message) {
                const errorEl = document.getElementById('nameError');
                const inputEl = document.getElementById('playerNameInput');
                errorEl.textContent = message;
                errorEl.classList.remove('hidden');
                inputEl.classList.add('error');

                // Clear error when user starts typing
                const clearError = () => {
                    errorEl.classList.add('hidden');
                    inputEl.classList.remove('error');
                    inputEl.removeEventListener('input', clearError);
                };
                inputEl.addEventListener('input', clearError);
            }

            async submitScore() {
                const nameInput = document.getElementById('playerNameInput');
                const playerName = nameInput.value.trim() || 'Anonymous';
                const submitBtn = document.getElementById('submitScoreBtn');

                // Check for inappropriate name
                if (containsInappropriateContent(playerName)) {
                    this.showNameError('Please choose an appropriate name');
                    return;
                }

                // Check name length
                if (playerName.length < 2) {
                    this.showNameError('Name must be at least 2 characters');
                    return;
                }

                // Remember the player name
                localStorage.setItem('pinchTheBugPlayerName', playerName);

                // Check if Supabase is available
                if (!supabaseClient) {
                    console.error('Supabase not initialized');
                    this.currentPlayerName = playerName;
                    this.hideModal('nameModal');
                    this.showLeaderboard();
                    return;
                }

                // Disable button while submitting
                submitBtn.disabled = true;
                submitBtn.textContent = 'Saving...';

                try {
                    // Check if player already exists (get their highest score entry)
                    const { data: existingPlayers, error: fetchError } = await supabaseClient
                        .from('leaderboard')
                        .select('*')
                        .eq('player_name', playerName)
                        .order('score', { ascending: false })
                        .limit(1);

                    if (fetchError) {
                        console.error('Error fetching player:', fetchError);
                        throw fetchError;
                    }

                    const existingPlayer = existingPlayers && existingPlayers.length > 0 ? existingPlayers[0] : null;
                    console.log('Existing player:', existingPlayer, 'New score:', this.finalScore);

                    if (existingPlayer) {
                        // Player exists - update only if new score is higher
                        if (this.finalScore > existingPlayer.score) {
                            console.log('New high score! Deleting old entry and inserting new one');

                            // Delete old entry
                            const { error: deleteError } = await supabaseClient
                                .from('leaderboard')
                                .delete()
                                .eq('id', existingPlayer.id);

                            if (deleteError) {
                                console.error('Delete error:', deleteError);
                                // Continue anyway, will insert new entry
                            }

                            // Insert new entry with higher score
                            const { data: insertData, error: insertError } = await supabaseClient
                                .from('leaderboard')
                                .insert([
                                    { player_name: playerName, score: this.finalScore }
                                ])
                                .select();

                            if (insertError) {
                                console.error('Insert error:', insertError);
                                throw insertError;
                            }
                            console.log('New high score saved:', insertData);
                        } else {
                            console.log('Score not higher than existing:', existingPlayer.score);
                        }
                    } else {
                        // New player - insert new row
                        console.log('Inserting new player:', playerName);
                        const { data: insertData, error: insertError } = await supabaseClient
                            .from('leaderboard')
                            .insert([
                                { player_name: playerName, score: this.finalScore }
                            ])
                            .select();

                        if (insertError) {
                            console.error('Insert error:', insertError);
                            throw insertError;
                        }
                        console.log('Insert result:', insertData);
                    }

                    this.currentPlayerName = playerName;
                    this.hideModal('nameModal');
                    this.showLeaderboard();

                } catch (error) {
                    console.error('Error saving score:', error);
                    alert('Failed to save score. Please try again.');
                } finally {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Submit Score';
                }
            }

            async showLeaderboard() {
                const listContainer = document.getElementById('leaderboardList');
                const yourScoreBox = document.getElementById('yourScoreBox');
                this.showModal('gameOverModal');

                // Check if Supabase is available
                if (!supabaseClient) {
                    listContainer.innerHTML = '<p style="text-align: center; opacity: 0.7;">Leaderboard unavailable</p>';
                    document.getElementById('gameOverPagination').classList.add('hidden');
                    yourScoreBox.style.display = 'none';
                    return;
                }

                listContainer.innerHTML = '<div class="loading-spinner">Loading leaderboard...</div>';

                try {
                    // Fetch all scores from Supabase
                    const { data, error } = await supabaseClient
                        .from('leaderboard')
                        .select('*')
                        .order('score', { ascending: false });

                    if (error) throw error;

                    if (!data || data.length === 0) {
                        listContainer.innerHTML = '<p style="text-align: center; opacity: 0.7;">No scores yet. Be the first!</p>';
                        document.getElementById('gameOverPagination').classList.add('hidden');
                        yourScoreBox.style.display = 'none';
                        return;
                    }

                    // Find current player's rank
                    let playerRank = '-';
                    const playerName = this.currentPlayerName || localStorage.getItem('pinchTheBugPlayerName') || 'You';

                    if (this.currentPlayerName) {
                        const playerIndex = data.findIndex(entry =>
                            entry.player_name === this.currentPlayerName &&
                            entry.score === this.finalScore
                        );
                        if (playerIndex !== -1) {
                            playerRank = `#${playerIndex + 1}`;
                        }
                    }

                    // Update your score box
                    document.getElementById('yourRank').textContent = playerRank;
                    document.getElementById('yourName').textContent = this.escapeHtml(playerName);
                    document.getElementById('yourScore').textContent = this.finalScore;
                    yourScoreBox.style.display = 'block';

                    // Store data and render first page
                    this.leaderboardData = data;
                    this.leaderboardPage = 0;
                    this.leaderboardContext = 'gameOver';
                    this.renderLeaderboardPage();

                } catch (error) {
                    console.error('Error fetching leaderboard:', error);
                    listContainer.innerHTML = '<p style="text-align: center; color: #ef4444;">Failed to load leaderboard</p>';
                    document.getElementById('gameOverPagination').classList.add('hidden');
                    yourScoreBox.style.display = 'none';
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            async viewLeaderboardFromMenu() {
                this.hideModal('startModal');
                const listContainer = document.getElementById('menuLeaderboardList');
                listContainer.innerHTML = '<div class="loading-spinner">Loading leaderboard...</div>';
                this.showModal('leaderboardModal');

                if (!supabaseClient) {
                    listContainer.innerHTML = '<p style="text-align: center; opacity: 0.7;">Leaderboard unavailable</p>';
                    document.getElementById('menuPagination').classList.add('hidden');
                    return;
                }

                try {
                    // Fetch all scores from Supabase
                    const { data, error } = await supabaseClient
                        .from('leaderboard')
                        .select('*')
                        .order('score', { ascending: false });

                    if (error) throw error;

                    if (!data || data.length === 0) {
                        listContainer.innerHTML = '<p style="text-align: center; opacity: 0.7;">No scores yet. Be the first!</p>';
                        document.getElementById('menuPagination').classList.add('hidden');
                        return;
                    }

                    // Store data and render first page
                    this.leaderboardData = data;
                    this.leaderboardPage = 0;
                    this.leaderboardContext = 'menu';
                    this.renderLeaderboardPage();

                } catch (error) {
                    console.error('Error fetching leaderboard:', error);
                    listContainer.innerHTML = '<p style="text-align: center; color: #ef4444;">Failed to load leaderboard</p>';
                    document.getElementById('menuPagination').classList.add('hidden');
                }
            }

            renderLeaderboardPage() {
                const isMenu = this.leaderboardContext === 'menu';
                const listContainer = document.getElementById(isMenu ? 'menuLeaderboardList' : 'leaderboardList');
                const paginationContainer = document.getElementById(isMenu ? 'menuPagination' : 'gameOverPagination');
                const prevBtn = document.getElementById(isMenu ? 'menuPrevBtn' : 'gameOverPrevBtn');
                const nextBtn = document.getElementById(isMenu ? 'menuNextBtn' : 'gameOverNextBtn');
                const pageInfo = document.getElementById(isMenu ? 'menuPageInfo' : 'gameOverPageInfo');

                const totalPages = Math.ceil(this.leaderboardData.length / this.leaderboardPageSize);
                const startIndex = this.leaderboardPage * this.leaderboardPageSize;
                const endIndex = Math.min(startIndex + this.leaderboardPageSize, this.leaderboardData.length);
                const pageData = this.leaderboardData.slice(startIndex, endIndex);

                let html = '';
                pageData.forEach((entry, i) => {
                    const rank = startIndex + i + 1;
                    const isCurrentPlayer = !isMenu && this.currentPlayerName &&
                        entry.player_name === this.currentPlayerName &&
                        entry.score === this.finalScore;
                    html += `<div class="leaderboard-item ${isCurrentPlayer ? 'current-player' : ''}">
                        <span class="leaderboard-rank">#${rank}</span>
                        <span class="leaderboard-name">${this.escapeHtml(entry.player_name)}</span>
                        <span class="leaderboard-score">${entry.score}</span>
                    </div>`;
                });
                listContainer.innerHTML = html;

                // Show/hide pagination based on total count
                if (this.leaderboardData.length > this.leaderboardPageSize) {
                    paginationContainer.classList.remove('hidden');
                    prevBtn.disabled = this.leaderboardPage === 0;
                    nextBtn.disabled = this.leaderboardPage >= totalPages - 1;
                    pageInfo.textContent = `Page ${this.leaderboardPage + 1} of ${totalPages}`;
                } else {
                    paginationContainer.classList.add('hidden');
                }

                // Clear current player after rendering game over leaderboard
                if (!isMenu) {
                    this.currentPlayerName = null;
                }
            }

            getRandomBugType() {
                // Weighted random selection
                const totalWeight = this.bugTypes.reduce((sum, type) => sum + type.weight, 0);
                let random = Math.random() * totalWeight;

                for (const bugType of this.bugTypes) {
                    random -= bugType.weight;
                    if (random <= 0) {
                        return bugType;
                    }
                }
                return this.bugTypes[0]; // Fallback
            }

            spawnTarget() {
                const bugType = this.getRandomBugType();
                const padding = bugType.size + 20;

                // Find valid position (not overlapping existing targets)
                let x, y, valid;
                let attempts = 0;

                do {
                    x = padding + Math.random() * (this.canvas.width - padding * 2);
                    y = padding + Math.random() * (this.canvas.height - padding * 2);

                    valid = true;
                    for (const target of this.targets) {
                        const dist = Math.hypot(x - target.x, y - target.y);
                        if (dist < (bugType.size + target.size)) {
                            valid = false;
                            break;
                        }
                    }
                    attempts++;
                } while (!valid && attempts < 20);

                this.targets.push(new Bug(
                    x, y,
                    bugType,
                    this.canvas.width,
                    this.canvas.height
                ));
            }

            updateScoreDisplay() {
                document.querySelector('#score .stat-value').textContent = this.score;
            }

            initFlipTimer() {
                // Set initial timer values without animation
                const time = Math.max(0, this.timeRemaining);
                const tens = Math.floor(time / 10);
                const ones = time % 10;

                this.setDigitValue('digit-tens', tens);
                this.setDigitValue('digit-ones', ones);
            }

            setDigitValue(digitId, value) {
                const digitEl = document.getElementById(digitId);
                digitEl.querySelector('.digit-top span').textContent = value;
                digitEl.querySelector('.digit-bottom span').textContent = value;
                digitEl.dataset.value = value;
            }

            updateTimerDisplay() {
                const time = Math.max(0, this.timeRemaining);
                const tens = Math.floor(time / 10);
                const ones = time % 10;

                this.updateFlipDigit('digit-tens', tens);
                this.updateFlipDigit('digit-ones', ones);

                // Add warning class when time is low
                const tensDigit = document.getElementById('digit-tens');
                const onesDigit = document.getElementById('digit-ones');
                if (time <= 10) {
                    tensDigit.classList.add('warning');
                    onesDigit.classList.add('warning');
                } else {
                    tensDigit.classList.remove('warning');
                    onesDigit.classList.remove('warning');
                }
            }

            updateFlipDigit(digitId, newValue) {
                const digitEl = document.getElementById(digitId);
                const currentValue = parseInt(digitEl.dataset.value || digitEl.querySelector('.digit-top span').textContent);

                if (currentValue !== newValue) {
                    const flipTop = digitEl.querySelector('.digit-flip-top');
                    const flipBottom = digitEl.querySelector('.digit-flip-bottom');

                    // Set up flip panels with old value (top) and new value (bottom)
                    if (!flipTop.querySelector('span')) {
                        flipTop.innerHTML = '<span></span>';
                        flipBottom.innerHTML = '<span></span>';
                    }
                    flipTop.querySelector('span').textContent = currentValue;
                    flipBottom.querySelector('span').textContent = newValue;

                    // Update bottom static panel to show new value (visible under flip)
                    digitEl.querySelector('.digit-bottom span').textContent = newValue;

                    // Remove old animation class and force reflow
                    digitEl.classList.remove('flipping');
                    void digitEl.offsetWidth;

                    // Start flip animation
                    digitEl.classList.add('flipping');

                    // After animation, update top panel and remove animation class
                    setTimeout(() => {
                        digitEl.querySelector('.digit-top span').textContent = newValue;
                        digitEl.classList.remove('flipping');
                        digitEl.dataset.value = newValue;
                    }, 450);

                    digitEl.dataset.value = newValue;
                }
            }

            showModal(id) {
                document.getElementById(id).classList.remove('hidden');
            }

            hideModal(id) {
                document.getElementById(id).classList.add('hidden');
            }

            hideAllModals() {
                document.querySelectorAll('.modal').forEach(m => m.classList.add('hidden'));
            }

            gameLoop(timestamp) {
                const deltaTime = timestamp - this.lastFrameTime;
                this.lastFrameTime = timestamp;

                this.update(deltaTime);
                this.render();

                requestAnimationFrame((t) => this.gameLoop(t));
            }

            update(deltaTime) {
                if (this.state !== 'PLAYING') return;

                const settings = this.settings;

                // Spawn new targets
                if (Date.now() - this.lastSpawnTime > settings.spawnInterval) {
                    if (this.targets.filter(t => !t.hit).length < 6) {
                        this.spawnTarget();
                    }
                    this.lastSpawnTime = Date.now();
                }

                // Dwell tracking - point swatter at bug to squash
                if (this.cursorVisible && !this.isSquashing) {
                    let hoveredBug = null;

                    // Find bug under swatter
                    for (const target of this.targets) {
                        if (!target.hit && target.checkHit(this.cursorX, this.cursorY)) {
                            hoveredBug = target;
                            break;
                        }
                    }

                    if (hoveredBug) {
                        // Accumulate dwell time
                        if (this.currentTarget === hoveredBug) {
                            hoveredBug.dwellTime += deltaTime;

                            // Squash if dwell threshold reached
                            if (hoveredBug.dwellTime >= hoveredBug.dwellThreshold) {
                                this.isSquashing = true;
                                this.squashStartTime = Date.now();
                                this.hitTarget(hoveredBug);
                                this.currentTarget = null;
                            }
                        } else {
                            // New target - reset previous target's dwell time
                            if (this.currentTarget) {
                                this.currentTarget.dwellTime = 0;
                            }
                            this.currentTarget = hoveredBug;
                            hoveredBug.dwellTime = deltaTime;
                        }
                    } else {
                        // Not hovering any bug
                        if (this.currentTarget) {
                            this.currentTarget.dwellTime = 0;
                            this.currentTarget = null;
                        }
                    }
                } else if (!this.cursorVisible) {
                    // Cursor not visible - reset dwell
                    if (this.currentTarget) {
                        this.currentTarget.dwellTime = 0;
                        this.currentTarget = null;
                    }
                }

                // Update squash animation
                if (this.isSquashing) {
                    const elapsed = Date.now() - this.squashStartTime;
                    if (elapsed >= this.squashDuration) {
                        this.isSquashing = false;
                    }
                }

                // Update targets (bugs) - pass cursor position for eye tracking
                this.targets = this.targets.filter(target =>
                    target.update(deltaTime, this.canvas.width, this.canvas.height, this.cursorX, this.cursorY)
                );
            }

            drawCuttingMatBackground() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                // Main green background
                ctx.fillStyle = '#1B8B6A';
                ctx.fillRect(0, 0, w, h);

                // Outer border (darker edge)
                const borderWidth = 25;
                ctx.strokeStyle = '#147256';
                ctx.lineWidth = borderWidth * 2;
                ctx.strokeRect(0, 0, w, h);

                // Inner border line
                ctx.strokeStyle = '#2BA37E';
                ctx.lineWidth = 2;
                ctx.strokeRect(borderWidth, borderWidth, w - borderWidth * 2, h - borderWidth * 2);

                // Grid settings
                const gridSize = 30; // Size of each grid cell
                const smallGridSize = gridSize / 5; // Smaller subdivisions

                // Draw small grid lines (lighter)
                ctx.strokeStyle = 'rgba(43, 163, 126, 0.3)';
                ctx.lineWidth = 0.5;

                // Vertical small lines
                for (let x = borderWidth; x < w - borderWidth; x += smallGridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, borderWidth);
                    ctx.lineTo(x, h - borderWidth);
                    ctx.stroke();
                }

                // Horizontal small lines
                for (let y = borderWidth; y < h - borderWidth; y += smallGridSize) {
                    ctx.beginPath();
                    ctx.moveTo(borderWidth, y);
                    ctx.lineTo(w - borderWidth, y);
                    ctx.stroke();
                }

                // Draw main grid lines (more visible)
                ctx.strokeStyle = 'rgba(43, 163, 126, 0.6)';
                ctx.lineWidth = 1;

                // Vertical main lines
                for (let x = borderWidth; x < w - borderWidth; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, borderWidth);
                    ctx.lineTo(x, h - borderWidth);
                    ctx.stroke();
                }

                // Horizontal main lines
                for (let y = borderWidth; y < h - borderWidth; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(borderWidth, y);
                    ctx.lineTo(w - borderWidth, y);
                    ctx.stroke();
                }

                // Draw thicker lines every 5 cells (like cm markings)
                ctx.strokeStyle = 'rgba(43, 163, 126, 0.8)';
                ctx.lineWidth = 1.5;

                // Vertical thick lines
                for (let x = borderWidth; x < w - borderWidth; x += gridSize * 5) {
                    ctx.beginPath();
                    ctx.moveTo(x, borderWidth);
                    ctx.lineTo(x, h - borderWidth);
                    ctx.stroke();
                }

                // Horizontal thick lines
                for (let y = borderWidth; y < h - borderWidth; y += gridSize * 5) {
                    ctx.beginPath();
                    ctx.moveTo(borderWidth, y);
                    ctx.lineTo(w - borderWidth, y);
                    ctx.stroke();
                }
            }

            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw cutting mat background
                this.drawCuttingMatBackground();

                if (this.state === 'PLAYING' || this.state === 'PAUSED') {
                    // Draw targets
                    for (const target of this.targets) {
                        target.draw(this.ctx);
                    }

                    // Draw fly swatter cursor
                    if (this.cursorVisible) {
                        this.ctx.save();
                        this.ctx.translate(this.cursorX, this.cursorY);

                        // Calculate squash animation progress
                        let squashProgress = 0;
                        if (this.isSquashing) {
                            const elapsed = Date.now() - this.squashStartTime;
                            squashProgress = Math.min(1, elapsed / this.squashDuration);
                            // Bounce effect: quick down, slower up
                            if (squashProgress < 0.3) {
                                squashProgress = squashProgress / 0.3; // Quick down
                            } else {
                                squashProgress = 1 - ((squashProgress - 0.3) / 0.7); // Slower up
                            }
                        }

                        // Calculate dwell progress for visual feedback
                        let dwellProgress = 0;
                        if (this.currentTarget && !this.currentTarget.hit) {
                            dwellProgress = Math.min(1, this.currentTarget.dwellTime / this.currentTarget.dwellThreshold);
                        }

                        // Swatter tilts based on dwell progress (ready to squash)
                        const tiltAngle = dwellProgress * 0.3; // Max 0.3 radians tilt
                        const squashScale = this.isSquashing ? 1 + squashProgress * 0.3 : 1;
                        const squashY = this.isSquashing ? squashProgress * 15 : 0;

                        this.ctx.rotate(-0.3 + tiltAngle); // Base angle + tilt
                        this.ctx.translate(0, squashY);
                        this.ctx.scale(squashScale, this.isSquashing ? 1 - squashProgress * 0.2 : 1);

                        // Swatter head (mesh part)
                        const headWidth = 50;
                        const headHeight = 60;

                        // Swatter color based on state
                        let swatterColor = '#4ade80'; // Green default
                        if (this.isSquashing) {
                            swatterColor = '#ef4444'; // Red when squashing
                        } else if (dwellProgress > 0.5) {
                            swatterColor = '#f97316'; // Orange when almost ready
                        } else if (dwellProgress > 0) {
                            swatterColor = '#fbbf24'; // Yellow when dwelling
                        }

                        // Swatter head outline
                        this.ctx.beginPath();
                        this.ctx.roundRect(-headWidth/2, -headHeight/2, headWidth, headHeight, 8);
                        this.ctx.fillStyle = swatterColor;
                        this.ctx.fill();
                        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                        this.ctx.lineWidth = 3;
                        this.ctx.stroke();

                        // Mesh pattern (grid lines)
                        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        this.ctx.lineWidth = 1.5;
                        // Vertical lines
                        for (let i = -headWidth/2 + 8; i < headWidth/2; i += 8) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(i, -headHeight/2 + 5);
                            this.ctx.lineTo(i, headHeight/2 - 5);
                            this.ctx.stroke();
                        }
                        // Horizontal lines
                        for (let i = -headHeight/2 + 8; i < headHeight/2; i += 8) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(-headWidth/2 + 5, i);
                            this.ctx.lineTo(headWidth/2 - 5, i);
                            this.ctx.stroke();
                        }

                        // Handle
                        const handleLength = 80;
                        const handleWidth = 10;
                        this.ctx.beginPath();
                        this.ctx.roundRect(-handleWidth/2, headHeight/2, handleWidth, handleLength, 3);
                        this.ctx.fillStyle = '#8B4513'; // Brown handle
                        this.ctx.fill();
                        this.ctx.strokeStyle = '#5D2E0C';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();

                        // Handle grip lines
                        this.ctx.strokeStyle = '#5D2E0C';
                        this.ctx.lineWidth = 1;
                        for (let i = headHeight/2 + 15; i < headHeight/2 + handleLength - 10; i += 12) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(-handleWidth/2 + 2, i);
                            this.ctx.lineTo(handleWidth/2 - 2, i);
                            this.ctx.stroke();
                        }

                        // Dwell progress ring around swatter head
                        if (dwellProgress > 0 && !this.isSquashing) {
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, headWidth/2 + 15, -Math.PI/2, -Math.PI/2 + dwellProgress * Math.PI * 2);
                            this.ctx.strokeStyle = swatterColor;
                            this.ctx.lineWidth = 5;
                            this.ctx.lineCap = 'round';
                            this.ctx.stroke();
                        }

                        // Squash impact effect
                        if (this.isSquashing && squashProgress > 0.2) {
                            const impactAlpha = (1 - squashProgress) * 0.6;
                            const impactRadius = 30 + squashProgress * 40;
                            const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, impactRadius);
                            gradient.addColorStop(0, `rgba(239, 68, 68, ${impactAlpha})`);
                            gradient.addColorStop(0.5, `rgba(239, 68, 68, ${impactAlpha * 0.5})`);
                            gradient.addColorStop(1, 'rgba(239, 68, 68, 0)');
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, impactRadius, 0, Math.PI * 2);
                            this.ctx.fillStyle = gradient;
                            this.ctx.fill();
                        }

                        this.ctx.restore();
                    }

                    // Draw points popups
                    if (this.pointsPopups) {
                        const now = Date.now();
                        this.pointsPopups = this.pointsPopups.filter(popup => {
                            const elapsed = now - popup.startTime;
                            if (elapsed >= popup.duration) return false;

                            const progress = elapsed / popup.duration;
                            const y = popup.y - progress * 50;
                            const alpha = 1 - progress;
                            const scale = 1 + progress * 0.5;

                            this.ctx.save();
                            this.ctx.font = `bold ${Math.round(24 * scale)}px 'Segoe UI', sans-serif`;
                            this.ctx.textAlign = 'center';
                            this.ctx.fillStyle = `rgba(74, 222, 128, ${alpha})`;
                            this.ctx.strokeStyle = `rgba(0, 0, 0, ${alpha * 0.5})`;
                            this.ctx.lineWidth = 3;
                            this.ctx.strokeText(`+${popup.points}`, popup.x, y);
                            this.ctx.fillText(`+${popup.points}`, popup.x, y);
                            this.ctx.restore();

                            return true;
                        });
                    }
                }
            }
        }

        // Mobile detection
        function isMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            // Check for mobile user agents
            const mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
            // Also check for touch-only devices with small screens
            const isSmallScreen = window.innerWidth <= 768;
            const isTouchOnly = 'ontouchstart' in window && !window.matchMedia('(pointer: fine)').matches;

            return mobileRegex.test(userAgent) || (isSmallScreen && isTouchOnly);
        }

        // Initialize game when page loads
        window.addEventListener('load', () => {
            if (isMobileDevice()) {
                // Show mobile not supported modal, hide start modal
                document.getElementById('startModal').classList.add('hidden');
                document.getElementById('mobileModal').classList.remove('hidden');
                return;
            }

            // Hide mobile modal, show start modal (default state)
            document.getElementById('mobileModal').classList.add('hidden');

            initSupabase();
            new Game();
        });
    </script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YTFHYG165E"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-YTFHYG165E');
    </script>
</body>
</html>
